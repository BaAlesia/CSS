1994 - CSS
Хокон Виум Ли (из Норвегии) предложил концепцию каскадных таблиц стилей.
Способы подключения CSS:

В head HTML-документа нужно добавить link со ссылкой на файл .css:
<link rel="stylesheet" href="style.css">

В head HTML-документа нужно добавить тэг “style”:
<style>
 .example {
  background: #ebac0c;
 }
</style>

Через атрибут “style”
Чтобы стилизовать конкретный элемент, можно использовать атрибут “style”:

<div style="border: 1px solid #000; margin-top: 16px;">Див со стилем</div>
Синтаксис внутри атрибута совпадает с синтаксисом внутри фигурных скобок в селекторе CSS.

Синтаксис CSS
Синтаксис CSS состоит из двух частей: селекторы и свойства. Селекторами мы указываем элементы, а свойствами описываем их стиль.

Селекторы
Селектор это правило, по которому будут выбраны элементы — например, мы можем обратиться ко всем параграфам или картинкам. Как?

p {} img {}
Свойства
Свойства пишутся у конкретных селекторов между фигурными скобками в формате ключ: значение.

Сложно? Вот пример как сделать у всех параграфов красный цвет и подчёркивание:

p {
 color: red;
 text-decoration: underline;
}
Каждое новое свойство пишется с новой строки.

После каждого свойства необходимо ставить точку с зяпятой.
Синтаксис CSS: практика
Всё гениальное - просто. Чем проще инструмент, тем более он удобен и прекрасен. CSS - один из таких инструментов. 
Его синтакисис состоит всего из двух единиц: селекторы и свойства.

Простые селекторы
HTML-документ состоит из элементов (чем элементы отличаются от тегов, мы рассказали в этом уроке). Чтобы задать стили элементу, необходимо к нему обратиться - «выбрать» его.

Давай посмотрим на примере:

<p>Привет, о многоуважаемый ученик!</p>
p {
    color: red;
}

Что мы сделали? Мы раскрасили текст "Привет, о многоуважаемый ученик!" в красный цвет. Как мы это сделали? 
Мы обратились ко всем элементам <p> и задали им красный цвет текста. Такой селектор называется селектор по тегу.
Селекторы не всегда такие простые, в следующих шагах мы рассмотрим разные виды селекторов. В общем виде синтаксис можно представить следующим образом:
селектор {
 свойство: значение;
}

Типы селекторов
Это основные типы селекторов. Есть и более сложные, но их очень редко используют даже опытные разработчики. Потому что один из главных принципов в написании кода - KISS.

Каждый селектор имеет свою специфичность – если стили в разных селекторах будут конфликтовать, применятся они будут в порядке специфичности – от более специфичному к менее специфичному.

Подробнее об этом на MDN: https://developer.mozilla.org/ru/docs/Web/CSS/Specificity

По тегу
Самый простой селектор - выбирает элементы по их тегу:

h1 {
   /* стили для всех h1 */
}
Этот селектор выберет все элементы <h1>.

По классу
Самый часто используемый селектор — по классу. Задаём в HTML класс элементам, к которым применить стиль:
<div class="card">
 Карточка
</div>
И теперь эти элементы можно выбрать по имени класса. Имя селектора начинается с точки:
.card {
   /* стили для всех элементов с class="card" */
   background: #333; /* фон серого цвета */
}
По id
Задавать стили по id - дурной тон, старайся его избегать. Тут всё тоже самое, что и с классом, только атрибут называется id:
<button id="button-go-to-top">
 Наверх
</button>
И имя селектора начинается с решётки:

#button-go-to-top {
   /* стили для элемента с id="button-go-to-top" */
   text-decoration: underline; /* подчёркивание текста */
}
По атрибуту 
Не самый популярный селектор, но иногда он полезен:
<button data-my-custom-attribute="my-custom-value">
 Нажми на меня
</button>
 Имя и значение атрибута пишется в квадратных скобках. Работает с любым атрибутом:
[data-my-custom-attribute="my-custom-value"] {
   color: red;
}
Любой элемент
Селектор * выбирает абсолютно любой элемент. Самый непопулярный селектор, обычно используется для костылей. 
Вряд ли он будет часто тебе нужен. Просто знай, что он есть.
* {
  margin: 0;
}
/* абсолютно всем элементам будет установлен margin: 0 */

Составные селекторы
Составные селекторы состоят из комбинации простых.

Группировка селекторов
Один и тот же набор свойств можно применить к разным селекторам. Пример:

button,
.button,
.cta-button {}

Нужно просто указать  через запятую все селекторы, к которым ты хочешь применить стили.
Элемент с классом
Можно стилизовать конкретный элемент, если у него есть определённый класс. Примеры:

p.example {}
Селектор выберет все p, у которых есть класс example.
.main.active {}
Селектор выберет все элементы с классом main, у которых также есть и класс active. Пример такого элемента:
<div class="main active">Пример</div>

Вложенность
Эти селекторы используются для выбора элементов, которые вложены в другие элементы.
Вложенность на любом уровне
Если между двумя простыми селекторами стоит пробел и ничего больше, это означает вложенность на любом уровне. Пример:
.page p {
 text-decoration: underline;
}
Этот селектор применит подчёркиваение ко всем <p>, которые находятся внутри элемента с классом page на любом уровне вложенности.

<div class="page">
 <p>Как писал Пелевин:</p>
 <div class="quote">
  <p>
   Человек привык видеть дьявола везде, кроме зеркала и телевизора.
  </p>
 </div>
</div>
Результат:
Вложенность на первом уровне
Правая угловая скобка > обозначает вложенность на первом уровне. Пример:
.page > p {
 text-decoration: underline;
}
Этот селектор применится ко всем <p>, которые находятся внутри элемента с классом page на первом уровне вложенности.

Как понимать составные селекторы
Хороший способ понимать смысл составных селекторов - читать их справа налево.
Давай попробуем разобраться на примере:
.page > .part {}
Этот селектор выберет все элементы .part, которые находятся на первом уровне вложенности в .page.
Здесь и дальше, вместо того, чтобы писать «элемент с class="part"», мы будем писать просто .part - точка вначале подразумевает, что это имя класса.
Ещё пример:
.main .side-menu .menu-item {}
Селектор применится ко всем элементам .menu-item, которые находятся внутри элементов .side-menu, которые находятся внутри элементов .main.

Селекторы, которые идут дальше, используются редко. Если ты не запомнишь как они работают, ничего страшного - самое главное ты знаешь, 
что они есть. Если что,  сможешь загуглить их при необходимости или использовать этот урок как справочник.

Элементы с определенным атрибутом
Можно задавать стили в зависимости от конкретного значения конретного атрибута. Пример:
input[type="password"] {}
Этот селектор выберет все элементы <input type="password">
Первый соседний элемент
Для того, чтобы выбрать элемент, который находится сразу после другого элемента, используется знак +. Пример:
img + p {
 margin-top: 0;
 font-style: italic;
}
Этот код применит стили во всех <p>, идущих сразу после <img>:
<img src="https://www.google.ru/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png" />
<p>Это лого гугла</p>
<p>А это просто абзац</p>

Любой соседний элемент
Для того, чтобы выбрать элемент, который находится после другого элемента, используется знак ~. Пример:

img ~ p {
 margin-top: 0;
 font-style: italic;
}
Этот код применит стили во всех <p>, идущих после <img>, даже если между img и p есть другие элементы.

Тип отображения элемента (display)
В уроке «Элементы и их виды», мы узнали, что есть два типа элементов - блочные и строчные. Кратко: блочные элементы занимают всю доступную ширину и начинаются с новой строчки. Строчные занимают столько места по ширине, сколько занимает их содержимое, выстраиваются в одну строчку и переносятся, если им не хватает места.

С помощью CSS-свойства display можно переопределить тип отображения элемента. Оно может иметь одно из следующих значений.

display: none; - элемент перестаёт отображаться на странице.

display: block; - блочный элемент. Ему можно задать ширину, высоту, границы, отступы.

display: inline; - строчный элемент. Задание ширины и высоты не влияет на inline элементы. Задание границ и отступов будет изменять 
положение окружающего текста, но не будет влиять на положение окружающих блочных элементов.
display: inline-block; - что-то среднее между блочным и строчным элементом. Ему можно задать ширину, высоту, границы и отступы, 
но он не будет создавать перенос строки до и после себя, в отличие от блочных элементов. С помощью этого типа можно распологать блоки горизонтально в ряд.
flex и inline-flex - это флексбоксы. Про них расскажем в уроке «Flexbox» в модуле «Продвинутая вёрстка». 
Элементы внутри них располагаются по определённым правилам, но снаружи они ведут себя как блоки и инлайн-блоки соотвественно.
В дальнейшем элементы с display block, inline-block, flex и inline-flex мы будем называть просто «блоки».
Блочная модель в CSS
Блокам можно задать:
ширину (width) и высоту (height)
отступы: внутренние (padding) и внешние (margin)
границы (border)
Эти свойства вместе с содержимым элемента составляют его блочную модель
Вот так выглядит её блочная модель:
margin - внешний отступ;
border - граница, между внутренним и внешним;
padding - внутренний отступ, под этим отступом продолжается фон элемента;
content - содержимое элемента;
Кстати
Размеры блока с незаданной шириной и высотой определяются по формуле: margin + padding + border + content. Эту особенность используют, 
чтобы создавать гибкие компоненты, которые будут изменять свои размеры в соответствии с содержимым.

Единицы измерения
Как ты уже знаешь, в CSS свойства имеют значения. Размерные значения обычно имеют единицу измерения.
Например, пиксели:
.example {
   width: 100px;
}
Чтобы не заниматься копипастой, сразу дадим ссылку на ресурс, где хорошо про это рассказывается  https://learn.javascript.ru/css-units. 
Используй его как справочник, когда понадобится.
Об этом нигде не сказано, но любую единицу измерения можно использовать для задания любого свойства, которое отвечает за размер.
Например, с помощью vh можно задавать размер шрифта.

Единицы измерения:
px – абсолютные пиксели, к которым привязаны и потому не нужны mm, cm, pt и pc. Используется для максимально конкретного и точного задания размеров.
em – задаёт размер относительно шрифта родителя, можно относительно конкретных символов: "x"(ex) и "0"(ch), 
используется там, где нужно упростить масштабирование компоненты.
rem – задаёт размер относительно шрифта <html>, используется для удобства глобального масштабирования: 
элементы которые планируется масштабировать, задаются в rem, а JS меняет шрифт у <html>.
% – относительно такого же свойства родителя (как правило, но не всегда), используется для ширин, высот и так далее, 
без него никуда, но надо знать, относительно чего он считает проценты.
vw, vh, vmin, vmax – относительно размера экрана.

Переполнение контента
Когда контент не вмещается в блок, происходит переполнение контента и в блоке появляется полоса прокрутки. Пример: https://codepen.io/mlshv/pen/ZmJgey
Свойство overflow управляет отображением содержания блочного элемента при переполнении.
Значения overflow:
overflow: visible; - отображается все содержание блока, даже за пределами установленной высоты и ширины.
overflow: hidden; - отображается только область внутри блока, остальное будет скрыто.
overflow: scroll; - всегда добавляются полосы прокрутки, даже если контент помещается.
overflow: auto; - полосы прокрутки добавляются только при необходимости.

Обтекание элементов (float)
Если у тебя получилось сделать второе домашнее задание, то ты знаешь свойство float. Оно задаёт, по какому краю (левому или правому) будет выровнен элемент. 
С противоположной стороны его будут обтекать другие элементы - текст и блоки.
Пример:
Картинка с фото со спутника обтекается текстом слева (float: right)
Свойство float может иметь следующие значения:
left - выравнивание по левой стороне, обтекание справа,
right  - выравнивание по правой стороне, обтекание слева,
none - выравнивание не задаётся (нужно, чтобы сбросить ранее заданное значение).
Clearfix
При использовании свойства float, новички испытывают проблемы. И все они вызваны нелогичным принципом работы float. 
Рассмотрим несколько проблем и попытаемся их решить.
Проблема 1
Родительский блок, который содержит только элементы со свойством float, "схлопывается" и принимает высоту равную нулю.
Проблема 2
Если в родительском блоке помимо "плавающих" (floating) элементов есть статические элементы, к которым мы не применяли float, 
то высота родителя станет равной высоте этих статических элементов. 
Проблема 3
Следствие проблемы 2. Такие "вываливающиеся" блоки будут обтекаться контентом блоков, которые идут после родительского. 
Решение
Чтобы избавиться от этих проблем, необходимо после "плавающих" блоков очищать обтекания, чтобы последующие элементы не стали обтекать "плавающие" блоки.
Самое простое решение - очищающий блок. После плавающих блоков нужно добавить еще один блок и задать ему CSS:
clear: both;

Позиционирование
Позиционирование определяет, к какой части страницы элемент будет «прикреплён».
Тип позиционирования задаётся с помощью свойства position. Разберём типы позиционирования.
Статическое позиционирование (static)
Этот тип стоит у элементов по умолчанию. Элемент располагается в потоке относительно остальных элементов на странице. 
В потоке, то есть в таком порядке, что он идёт после элементов, которые объявлены перед ним. И элементы, которые объявлены после него, идут после него.
<h1>Заголовок</h1>
<p>Абзац</p>
Вроде бы очевидно, что если заголовок объявлен раньше абзаца, то он будет под заголовком. Да? Да, но только для этого типа позиционирования.
Абсолютное позиционирование (absolute)
Забавно, что абсолютное позиционирование - тоже относительное. Но задаётся оно по-другому.
Положение абсолютного блока задаётся относительно страницы или относительно элемента с position: relative, в которой он вложен. 
Положение такого блока задаётся с помощью свойств top, right, bottom, left.
Например, расположим абзац из примера выше вверху экрана.  Для HTML кода из примера выше:
CSS:

p {
  position: absolute;
  top: 0;
}
Элементы со статическим позиционированием игнорируют абсолютные блоки, которые как бы "вываливаются" из потока и живут своей собственной жизнью. 
Как будто существуют на своём собственном слое.
Фиксированное позиционирование (fixed)
Задаётся так же, как и абсолютное, но блок прикрепляется не к странице, а к экрану. То есть при прокрутке страницы он остаётся на своём месте. 
Пример - шапка на степике.
Относительное позиционирование (position: relative)
Положение элемента устанавливается относительно его исходного места в потоке. Свойства left, top, right и bottom изменяет 
позицию элемента и сдвигает его в ту или иную сторону от первоначального расположения. А ещё оно работает как родитель, 
относительно которого можно задавать абсолютную позицию блокам, которые в него вложены.

Обзор доступных средств для расположения и позиционирования элементов на странице HTML с помощью CSS (CSS layout):

The normal flow.
Все элементы распологаются на странице последовательно, в том порядке, в котором они записаны в HTML.
Браузер размещает элементы страницы поочередно, сверху вниз, согласно блочной модели, учитывая margin-ы и padding-и.
Это называется нормальный (обычный) поток.
Подводные канми: "схлопывание" отступов.
 
Переполнение контента. Overflow.
Когда контент выходит за ширину или высоту родительского блока-контейнера, могут появиться полосы прокрутки. Настраивается с помощью overflow.
 
Свойство float.
"Плавающий" элемент (float : right; или float: left;) 
вынимается из потока и "прижимается" ("притягивается", "плывёт") к левой или правой стороне содержащего блока. 
Поток всё также идет от самого верха родительского элемента-контейнера, но ширина потока уменьшается на ширину плавающего элемента.
После "плавающего" элемента поток опять займёт всю доступную ширину.

Если элементы, которые обтекают вокруг float-элемента, меньше по высоте, то следующие за ними элементы продолжат "обтекать"  float-элемент.
Чтобы предотвратить обтекание, нужно для этих элементов установить свойство clear как right или left (не позволяет элементу обтекать 
другие с правой или с левой стороны)  или both (с обеих сторон).
По умолчанию все элементы  будут обтекать float-ы,  свойство clear имеет значение по умолчанию  clear: none;    -  отключено.

Если в блоке-контейнере нет элементов кроме плавающих (как в первом примере из предыдущего урока) его высота равна нулю, контейнер 
ведет себя как пустой, потому что плавающие элементы удалены из потока.
Чтобы контейнер не схлопывался в него добавляют пустой элемент со свойством clear: both;, его высота тоже - "0", но он не может обтекать 
плавающий элемент и  будет расположен после него, таким образом контейнер растянется.
All About Floats | CSS-Tricks
 
Позиционирование. Свойство Position.

static  и relative - элементы остаются в потоке документа.
static - установленно для всех элемнтов по-умолчанию, это поведение элемента в нормальном (обычном) потоке.
relative же смещает элемент относительно того места, где он должен находится в нормальном потоке. (top - смещение сверху на указанные единицы , 
right смещает относительно правой стороны "статичного" положения и тд и тп).
Если элемент имеет свойство position: static;  top, right, left, bottom для него не работают.
(В принципе, они могут "включиться", если изменить position на другое значение с помощью javascript)

absolute - элемент удаляется из потока и позиционируется относительно ближайщего позиционированного предка (т.е. любого не статичного).
Если такого предка нет, относительно <body> </body>.
Ширина потока не изменяется.
Элемент накладывается поверх или снизу остального контента (можно изменить с помощью z-index)
Когда абсолютное позиционирование можно использовать
Вот признаки элемента, к которому применимо абсолютное позиционирование:

Элемент сложно или невозможно расположить правильно без использования абсолютного позиционирования (чёткое понимание этого придёт во время практики, просто откладывай position: absolute на крайний случай).
Положение элемента зависит от границ его родителя.
От его положения не зависят другие элементы.

fixed - позиционируется относительно окна браузера и не изменяет своего положения при прокрутке.
fixed так же как absolute находится вне потока.

sticky - "липкий" - элемент будет застывает на месте при прокрутке, когда область просмотра достигнет определённой позиции.
Может изменять свое положение только внутри блока-контейнера. 

top, bottom, right и left устанавливают точку, в которой элемент "залипает".
Когда будет достигнуто установленное значение, элемент остановится на одном месте как  fixed, до тех пор, пока, при прокрутке, не достигнет конца блока-контейнера.
Другими словами, "хочет" быть fixed, но может перемещаться только внутри содержащего контейнера.
подробнее
Модуль flexbox
Модуль grid 

Псевдоклассы
Псевдоклассы - это ключевые слова, которые добавляются к селектору. Стили, заданные таким образом, применяются только для определённых состояний.
Например, :hover может быть использован для изменения цвета кнопки при наведении курсора:
button:hover {
   background: red;
}
Стили псевдокласса переопределяют заданные ранее стили, если они есть. Пример:
button {
  border: 1px solid black;
  padding: 8px 16px;
  background: #c9c9c9;
}
button:hover {
  background: #e9e9e9;
}

Результат выполнения: https://codepen.io/mlshv/pen/zyGdzq?editors=1100 (наведи мышь на кнопку)

Самые часто используемые псевдоклассы:
:hover - появляется при наведении мышки
:active - появляется при нажатии на элемент
:focus - появляется при фокусировке на элементе (например, когда выбрано поле ввода текста)
Подробнее про псевдоклассы читай на MDN. Здесь же есть полный список псевдоклассов.
Анимация переходов
Переходы состояний некоторых в CSS можно анимировать. Это работает так: если значение свойства меняется, то вместо резкого изменения, происходит плавный переход. Пример:

 



 

Вот так выглядит анимирование переходов в коде:

button {
    border-radius: 4px;
    transition: border-radius 0.5s ease-in;
}

button:hover {
    border-radius: 16px;
}

За анимацию отвечает свойство transition. 

свойство, изменения которого нужно анимировать (если нужно анимировать несколько, можно написать all)
продолжительность анимации в секундах (рекомендуется не ставить её больше 0.3 секунды)
функция плавности, подробнее здесь: https://easings.net/ru
Вот полный список доступных для анимаций свойств: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties

Медиа-запросы
Медиа-запросы позволяют задавать стили для определенных типов устройств, например, принтеры, экраны или синтезаторы речи.
В примерах мы будем рассматривать медиа-запросы для экранов различной ширины. Остальные типы используются редко, просто знай, 
что они есть, чтобы загуглить, когда понадобится.
Чаще всего они используются, чтобы создавать адаптивные страницы.
Синтаксис
Синтаксис медиа-запроса выглядит так:
@media правило {
   /* обычный CSS-код, который применится при соблюдении правила */
}
Пример медиа-запроса:
@media screen and (max-width: 320px) {
    img {
        width: 100%;
    }
}
Этот код означает следующее: на экранах, ширина которых меньше или равна 320px, картинки будут иметь ширину 100%.
Подробнее про синтаксис читай в документации MDN: https://developer.mozilla.org/ru/docs/Web/CSS/Media_Queries/Using_media_queries
